# ['1', '2', '3'].map(parseInt)

map参数是一个函数，函数接受的参数有三个，value，key，array

parseInt函数有两个参数，第一个是需要转换成整数的值，第二个是转换成整数的进制

上面转换就是parseInt('1', 0)，0的话如果转化字符串不是0x或0开头是以10为基数

上面转换就是parseInt('2', 1)

上面转换就是parseInt('3', 2)

# 手写防抖节流

# Set,Map,WeakSet,WeatMap的区别

- Set允许存储任意类型的唯一值
- WeakSet只能存储对象，所有的成员都是弱引用，这就意味着，如果没有其他强引用引用的对象即使在WeakSet中也会被垃圾回收
- Map本质上是键值对的集合
- WeakMap只接受对象作为键名，值可以是任意的，键名的规则和WeakSet类似

WeakSet合WeakMap的使用场景

- 缓存，不常用的数据可以使用这俩存储，当缓存数据不需要的时候会自动被垃圾回收
- 存储dom元素，当dom元素从文档中移除的时候，如果使用的set或者map将不会被垃圾回收

# 深度优先和广度优先
- 深度优先遍历——是指从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止。
- 广度优先遍历——是从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止。

# 用深度优先和广度优先实现深拷贝

# 手写async函数

# 已知如下数组，编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

# Promise 构造函数是同步执行，then方法是异步执行

# 实现一个new

# 回流和重绘

# 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景

这俩模式其实有一定的相同点，都是为了实现对象之间的通信和数据同步

## 观察者模式

定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当主体对象发生变化时，他的所有依赖对象都会自动收到通知并且进行自己的更新操作。

在观察者模式中，主题对象和依赖的观察者对象是互相感知的，主题对象会维护一个观察者列表，当自身发生变化时会自动遍历所有的观察者出发更新

### 主要适用场景
一对多的关系，一个对象发生改变将会通知多个对象。

## 发布订阅模式

存在发布者和订阅者，但是这俩对象没有任何直接关系，通过第三方组件（如消息队列和事件总线）来实现发布者和订阅者之间的通信

订阅者会从第三方组件订阅消息，发布者会发布消息到第三方组件

发布者和订阅者互相感知不到自己的存在，也不需要知道对方的存在

### 主要适用场景

可以是一种多对多的关系

- 需要实现解耦的通信，发布者和订阅者之间不需要直接建立联系。
- 当有多个发布者和多个订阅者时，可以实现更加灵活的消息传递和路由

### Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法
不能简单的进行性能比较，首先单说性能的话肯定原生dom是快的，因为Virtual DOM本质上还是操作原生dom的，增加了js逻辑层的处理，那么为什么需要Virtual DOM呢

- 执行效率和性能优化，原生dom操作涉及到浏览器的布局计算和渲染，如果我们每次innerHTML修改的话就会有大量的性能损耗，Virtual DOM就是在我们的逻辑层面对每次视图变化时产生的两棵新旧节点树进行diff处理，找出差异点，只更新部分节点，从而减少页面渲染的开销，提高性能，在大量dom操作下，Virtual DOM在性能上是有优势的

- 开发效率，在我们之前的开发中比如jquery时代，每次数据改变都要操作底层dom，比如getElementById('xx').innenrHTML或者append，使得我们在数据修改后还要再多关注视图层的修改，较为繁琐。Virtual DOM会使得我们的操作更加灵活，借助vue，react等框架，我们只需要关心数据变化就好了，大大提高了开发效率

- 首次渲染与内存消耗，在首次渲染大量dom时，由于Virtual DOM多了一层计算，肯定会比innenrHTML会慢，另外Virtual DOM本身是占用内存空间的，因此只要我们的页面越复杂，Virtual DOM就会越大，内存消耗也就越大

### 迭代方式实现flatten函数

### 下面代码中 a 在什么情况下会打印 1？

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
  console.log(1);
}
```

a = {
  val: 1
}
a.toString = function() {
  return a.val++
}

### 实现一个sleep函数

### 实现 (5).add(3).minus(2) 功能

### 某公司 1 到 12 月份的销售额存在一个对象里面

如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。

```js
var data = {1:222, 2:123, 5:888}
let res = Array.from({length: 12}).map((item, index) => data[index+1] || null)
```
```js
var data = {1:222, 2:123, 5:888}
let monthData = new Array(12).fill(null)
for(var i in data) {
    monthData[i-1] = data[i]
}
```

### 要求设计 LazyMan 类，实现以下功能

### 设计一套并发架构

### jwt JSON Web Token

### 模拟实现一个 Promise.finally

### 请实现一个 add 函数，满足以下功能

### 周一算法题之「两数之和」

### 实现 convert 方法，把原始 list 转换成树形结构

### 设计并实现 Promise.race()

### 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。


